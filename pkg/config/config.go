package config

import (
	"errors"
	"fmt"

	"github.com/xavi06/jenkins-x-lite/pkg/util"
	"github.com/xavi06/viper"
)

// Config struct
type Config struct {
	Name      string
	Apptype   string
	Gitrepo   string
	Gitbranch string
	PID       int
	Replica   int
}

var (
	namespace        = "default"
	appbase          = "helloworld-maven-0.5.1.tgz"
	pipeline         = "jenkins"
	cluster          = "c1"
	helmrepo         = "chartmuseum"
	apiversion       = "v1"
	appversion       = "1.0"
	version          = "0.1.0"
	description      = "A Helm chart for Kubernetes, Auto generated by jxl"
	imagepullsecrets = "myregistry"
	repository       = "jxregistry.docker.fccs.cn:28888"
	tag              = "latest"
	pullpolicy       = "IfNotPresent"
	port             = 8080
	projectid        = 100
	replicacount     = 1
	dnspolicy        = "ClusterFirst"
	servicetype      = "LoadBalancer"
	healthcheck      = "/health"
)

// CreateToml func
func CreateToml(fname string, config Config) error {

	if util.CheckFileExsit(fname) {
		errMsg := fmt.Sprintf("%s exist, please delete it first!", fname)
		return errors.New(errMsg)
	}

	viper.SetConfigType("toml")
	viper.SetKeysCaseSensitive(true)
	viper.Set("namespace", namespace)
	viper.Set("appbase", appbase)
	viper.Set("pipeline", pipeline)
	viper.Set("cluster", cluster)
	viper.Set("helmrepo", helmrepo)
	chart := map[string]string{
		"apiVersion":  apiversion,
		"appVersion":  appversion,
		"name":        config.Name,
		"version":     version,
		"description": description,
	}
	viper.Set("chart", chart)
	viper.Set("git", map[string]string{
		"repo":   config.Gitbranch,
		"branch": config.Gitrepo,
	})
	viper.Set("docker", map[string]string{
		"base":       "",
		"port":       "",
		"package":    "",
		"workdir":    "",
		"entrypoint": "",
		"cmd":        "",
	})

	switch config.Apptype {
	case "maven":
		viper.Set("jenkins", map[string]interface{}{
			"steps":        []string{"git", "prebuild", "mvn-package", "get-dockerfile", "build-and-push", "save-image-tag", "helm", "rsync"},
			"syncAddr":     []string{},
			"gitSecret":    "",
			"dockerSecret": "",
		})
	case "other":
		viper.Set("jenkins", map[string]interface{}{
			"steps":        []string{"git", "build-and-push", "helm"},
			"syncAddr":     []string{},
			"gitSecret":    "",
			"dockerSecret": "",
		})
	}
	helm := map[string]interface{}{
		"replicaCount":     config.Replica,
		"projectid":        config.PID,
		"imagePullSecrets": imagepullsecrets,
		"command":          []string{},
		"args":             []string{},
		"dnsPolicy":        dnspolicy,
		"image": map[string]string{
			"repository": repository,
			"name":       config.Name,
			"tag":        tag,
			"pullPolicy": pullpolicy,
		},
		"service": map[string]interface{}{
			"type":           servicetype,
			"port":           port,
			"targetport":     port,
			"loadBalancerIP": "",
			"healthCheck":    healthcheck,
		},
		"resources": map[string]interface{}{
			"requests": map[string]interface{}{
				"memory": "512Mi",
				"cpu":    "200m",
			},
			"limits": map[string]interface{}{
				"memory": "2048Mi",
				"cpu":    "1000m",
			},
		},
		"volumes": []map[string]interface{}{
			{
				"name": "tomcat-log",
				"hostPath": map[string]interface{}{
					"path": fmt.Sprintf("/var/log/dockerapp/%d/", config.PID),
				},
			},
		},
		"volumeMounts": []map[string]interface{}{
			{
				"name":      "tomcat-log",
				"mountPath": "/usr/local/tomcat/logs/",
			},
		},
		"env": map[string]interface{}{
			"podInfo": map[string]interface{}{
				"name": "podInfo",
				"data": map[string]interface{}{
					"MY_POD_NAME":      "metadata.name",
					"MY_POD_NAMESPACE": "metadata.namespace",
					"MY_POD_IP":        "status.podIP",
				},
			},
			"otherInfo": map[string]interface{}{
				"name": "otherInfo",
				"data": map[string]interface{}{
					"LANG":        "zh_CN.UTF-8",
					"XMS":         "512m",
					"XMX":         "1500m",
					"TOMCAT_LANG": "",
				},
			},
		},
		"securityContext": map[string]interface{}{
			"runAsUser": 1501,
			"fsGroup":   1501,
		},
	}
	viper.Set("helm", helm)
	return viper.WriteConfigAs(fname)

}
